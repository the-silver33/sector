// Costanti di configurazione
const PRIMA_RIGA = 2; // Prima riga da cui leggere i dati (riga 2 = dopo l'header)
const MAIN_SHEET_NAME = 'Foglio1'; // Nome del foglio principale
const RESPONSE_SHEET_NAME = 'Risposte del modulo 1'; // Nome del foglio delle risposte
const SHEET_ID = '1djpONz3rJtEce-bl4Wsy1q46NRl1jTMC3uKxN1hQMng'; // ID del foglio di lavoro

// Mappa delle colonne: approvata, matricola, password, nick, tipo, posizione, movimento, visione, armatura, rifornimenti, trasportata, componenti
const COLUMNS = {
  APPROVATA: 1,      // A
  MATRICOLA: 2,      // B
  PASSWORD: 3,       // C
  NICK: 4,           // D
  TIPO: 5,           // E
  POSIZIONE: 6,      // F
  MOVIMENTO: 7,      // G
  VISIONE: 8,        // H
  ARMATURA: 9,       // I
  RIFORNIMENTI: 10,  // J
  TRASPORTATA: 11,   // K
  COMPONENTI: 12     // L
};

/**
 * Funzione principale: legge i dati dal foglio principale e li posta all'API
 */
function postDataToAPI() {
  try {
    var spreadsheet = SpreadsheetApp.openById(SHEET_ID);
    var mainSheet = spreadsheet.getSheetByName(MAIN_SHEET_NAME);
    
    if (!mainSheet) {
      throw new Error('Foglio principale non trovato: ' + MAIN_SHEET_NAME);
    }
    
    // Legge i dati dalle colonne A-L dalla PRIMA_RIGA fino all'ultima riga non vuota
    var lastRow = mainSheet.getLastRow();
    
    if (lastRow < PRIMA_RIGA) {
      return createResponse({
        success: true,
        data: [],
        message: 'Nessun dato da processare'
      });
    }
    
    // Legge i dati dalle colonne A-L
    var dataRange = mainSheet.getRange(PRIMA_RIGA, COLUMNS.APPROVATA, lastRow - PRIMA_RIGA + 1, 12);
    var values = dataRange.getValues();
    
    // Converte i dati nel formato richiesto
    var apiData = [];
    
    for (var i = 0; i < values.length; i++) {
      var row = values[i];
      
      // Salta righe completamente vuote (controlla almeno la matricola)
      if (!row[COLUMNS.MATRICOLA - 1] || row[COLUMNS.MATRICOLA - 1] === '') {
        continue;
      }
      
      var dataItem = {
        "approvata": row[COLUMNS.APPROVATA - 1] || "NO",
        "matricola": row[COLUMNS.MATRICOLA - 1] || "N/A",
        "password": row[COLUMNS.PASSWORD - 1] || "N/A",
        "nick": row[COLUMNS.NICK - 1] || "N/A",
        "tipo": row[COLUMNS.TIPO - 1] || "N/A",
        "posizione": row[COLUMNS.POSIZIONE - 1] || "N/A",
        "movimento": row[COLUMNS.MOVIMENTO - 1] || "N/A",
        "visione": row[COLUMNS.VISIONE - 1] || "N/A",
        "armatura": row[COLUMNS.ARMATURA - 1] || "N/A",
        "rifornimenti": formatRifornimenti(row[COLUMNS.RIFORNIMENTI - 1]) || "N/A/N/A",
        "trasportata": row[COLUMNS.TRASPORTATA - 1] || "N/A",
        "componenti": row[COLUMNS.COMPONENTI - 1] || "N/A"
      };
      
      apiData.push(dataItem);
    }
    
    var payload = {
      success: true,
      data: apiData
    };
    
    // Qui puoi fare la chiamata all'API se necessario
    // var response = UrlFetchApp.fetch('URL_API', {
    //   method: 'post',
    //   contentType: 'application/json',
    //   payload: JSON.stringify(payload)
    // });
    
    console.log('Dati preparati per API: ' + apiData.length + ' record');
    
    return payload;
    
  } catch (error) {
    console.error('Errore in postDataToAPI:', error);
    return {
      success: false,
      message: error.toString(),
      data: []
    };
  }
}

/**
 * Formatta i rifornimenti nel formato "rifornimenti/rifornimenti"
 */
function formatRifornimenti(value) {
  if (!value || value === '' || value === 'N/A') {
    return 'N/A/N/A';
  }
  
  // Se già nel formato corretto, ritorna così com'è
  if (value.toString().includes('/')) {
    return value.toString();
  }
  
  // Altrimenti duplica il valore
  return value.toString() + '/' + value.toString();
}

/**
 * Trigger che si attiva quando il foglio delle risposte viene modificato
 */
function onEdit(e) {
  try {
    var sheet = e.source.getActiveSheet();
    
    // Controlla se la modifica è nel foglio delle risposte
    if (sheet.getName() === RESPONSE_SHEET_NAME) {
      // Piccola pausa per evitare conflitti
      Utilities.sleep(1000);
      
      // Processa le risposte dal form
      processFormResponses();
    }
  } catch (error) {
    console.error('Errore in onEdit:', error);
  }
}

/**
 * Processa le risposte dal foglio delle risposte del form
 */
function processFormResponses() {
  try {
    var spreadsheet = SpreadsheetApp.openById(SHEET_ID);
    var responseSheet = spreadsheet.getSheetByName(RESPONSE_SHEET_NAME);
    var mainSheet = spreadsheet.getSheetByName(MAIN_SHEET_NAME);
    
    if (!responseSheet || !mainSheet) {
      throw new Error('Fogli non trovati');
    }
    
    var lastRow = responseSheet.getLastRow();
    
    if (lastRow < 2) {
      return; // Nessuna risposta da processare
    }
    
    // Legge le colonne A (timestamp) e B (messaggio)
    var timestampColumn = responseSheet.getRange(2, 1, lastRow - 1, 1).getValues();
    var messageColumn = responseSheet.getRange(2, 2, lastRow - 1, 1).getValues();
    
    // Usa una colonna di tracking per evitare duplicati (es. colonna Z)
    var trackingColumnIndex = 26; // Colonna Z
    var processedRange = responseSheet.getRange(2, trackingColumnIndex, lastRow - 1, 1).getValues();
    
    for (var i = 0; i < messageColumn.length; i++) {
      var message = messageColumn[i][0];
      var isProcessed = processedRange[i][0] === 'PROCESSATO';
      
      // Salta righe vuote o già processate
      if (!message || message === '' || isProcessed) {
        continue;
      }
      
      // Controlla se il messaggio contiene "REGISTRAZIONE"
      if (message && message.toString().includes('REGISTRAZIONE')) {
        try {
          // Estrae i dati dal messaggio
          var extractedData = extractRegistrationData(message);
          
          // Trova la prima riga vuota nel foglio principale a partire da PRIMA_RIGA
          var emptyRow = findFirstEmptyRow(mainSheet);
          
          // Scrive i dati nella riga vuota
          writeDataToMainSheet(mainSheet, emptyRow, extractedData);
          
          // Marca come processato
          responseSheet.getRange(i + 2, trackingColumnIndex).setValue('PROCESSATO');
          
          console.log('Registrazione processata e aggiunta alla riga ' + emptyRow);
          
        } catch (error) {
          console.error('Errore processando riga ' + (i + 2) + ':', error);
          responseSheet.getRange(i + 2, trackingColumnIndex).setValue('ERRORE: ' + error.toString().substring(0, 50));
        }
      }
    }
    
  } catch (error) {
    console.error('Errore in processFormResponses:', error);
  }
}

/**
 * Estrae i dati di registrazione dal testo del messaggio
 * Formato esempio: "REGISTRAZIONE - Matricola: TEST_775, Password: testpass, Nick: TestUser1, Tipo: Fante, Movimento: 5, Visione: 3, Armatura: 2, Rifornimenti: 10, Componenti: Nessuno"
 */
function extractRegistrationData(message) {
  var data = {
    matricola: extractValue(message, 'Matricola:'),
    password: extractValue(message, 'Password:'),
    nick: extractValue(message, 'Nick:'),
    tipo: extractValue(message, 'Tipo:'),
    movimento: extractValue(message, 'Movimento:'),
    visione: extractValue(message, 'Visione:'),
    armatura: extractValue(message, 'Armatura:'),
    rifornimenti: extractValue(message, 'Rifornimenti:'),
    componenti: extractValue(message, 'Componenti:')
  };
  
  return data;
}

/**
 * Helper per estrarre valori dal testo
 */
function extractValue(text, key) {
  if (!text || !key) return null;
  
  var startIndex = text.indexOf(key);
  if (startIndex === -1) return null;
  
  startIndex += key.length;
  var endIndex = text.indexOf(',', startIndex);
  if (endIndex === -1) {
    // Se non trova una virgola, cerca la fine del testo o un'altra chiave
    var nextKey = text.indexOf(' - ', startIndex);
    if (nextKey !== -1) {
      endIndex = nextKey;
    } else {
      endIndex = text.length;
    }
  }
  
  var value = text.substring(startIndex, endIndex).trim();
  return value === '' ? null : value;
}

/**
 * Trova la prima riga vuota nel foglio principale a partire da PRIMA_RIGA
 * Una riga è considerata vuota se la colonna B (matricola) è vuota
 */
function findFirstEmptyRow(sheet) {
  var lastRow = sheet.getLastRow();
  
  // Se il foglio è vuoto o ha solo l'header, ritorna PRIMA_RIGA
  if (lastRow < PRIMA_RIGA) {
    return PRIMA_RIGA;
  }
  
  // Controlla dalla PRIMA_RIGA in giù
  var matricolaColumn = sheet.getRange(PRIMA_RIGA, COLUMNS.MATRICOLA, lastRow - PRIMA_RIGA + 1, 1).getValues();
  
  for (var i = 0; i < matricolaColumn.length; i++) {
    if (!matricolaColumn[i][0] || matricolaColumn[i][0] === '') {
      return PRIMA_RIGA + i;
    }
  }
  
  // Se tutte le righe sono piene, ritorna la riga successiva all'ultima
  return lastRow + 1;
}

/**
 * Scrive i dati estratti nel foglio principale nella riga specificata
 */
function writeDataToMainSheet(sheet, row, data) {
  // Prepara i valori per le colonne A-L
  var values = [
    'NO', // approvata (colonna A) - default "NO"
    data.matricola || 'N/A', // matricola (colonna B)
    data.password || 'N/A', // password (colonna C)
    data.nick || 'N/A', // nick (colonna D)
    data.tipo || 'N/A', // tipo (colonna E)
    'N/A', // posizione (colonna F) - default "N/A"
    data.movimento || 'N/A', // movimento (colonna G)
    data.visione || 'N/A', // visione (colonna H)
    data.armatura || 'N/A', // armatura (colonna I)
    formatRifornimenti(data.rifornimenti), // rifornimenti (colonna J) - formato "rifornimenti/rifornimenti"
    'N/A', // trasportata (colonna K) - default "N/A"
    data.componenti || 'N/A' // componenti (colonna L)
  ];
  
  // Scrive i valori nella riga specificata, colonne A-L
  sheet.getRange(row, COLUMNS.APPROVATA, 1, 12).setValues([values]);
}

/**
 * Funzione per installare il trigger onEdit
 * Da eseguire una volta manualmente per configurare il trigger
 */
function installOnEditTrigger() {
  try {
    // Rimuove trigger esistenti per evitare duplicati
    var triggers = ScriptApp.getProjectTriggers();
    triggers.forEach(function(trigger) {
      if (trigger.getHandlerFunction() === 'onEdit') {
        ScriptApp.deleteTrigger(trigger);
      }
    });
    
    // Crea il nuovo trigger
    ScriptApp.newTrigger('onEdit')
      .forSpreadsheet(SHEET_ID)
      .onEdit()
      .create();
    
    console.log('Trigger onEdit installato con successo!');
  } catch (error) {
    console.error('Errore installazione trigger:', error);
  }
}

/**
 * Funzione di test per verificare il funzionamento
 */
function testPostDataToAPI() {
  var result = postDataToAPI();
  console.log('Risultato test:', JSON.stringify(result, null, 2));
  return result;
}

/**
 * Funzione di test per processare manualmente le risposte
 */
function testProcessFormResponses() {
  processFormResponses();
  console.log('Processamento risposte completato');
}

/**
 * Funzione helper per creare risposte JSON
 */
function createResponse(data) {
  return ContentService
    .createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

